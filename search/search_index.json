{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#fehujs-documentation","title":"Fehujs documentation","text":"<p>Welcome on the official documentation website of fehujs.</p>"},{"location":"#about-the-project","title":"About the project","text":"<p>This is a project built by a french student for educational purposes. It isn't meant to be used in real production contexts, but to understand how a big open source project could be organized &amp; how APIs and web servers works.</p> <p>Fehu is a rune, you can learn more about it on Wikipedia.</p>"},{"location":"#organization","title":"Organization","text":"<p>The project is organized of many different modules that are designed to be the most independent, with as few external dependencies as possible.</p>"},{"location":"#modules","title":"Modules","text":"<ul> <li>create-fehujs-app: create fehu app module</li> <li>@fehujs/auth: User authentication build-in module for Fehujs apps</li> <li>@fehujs/csrf-shield: CSRF protection module</li> <li>@fehujs/database: Fehujs database package</li> <li>@fehujs/helpers: Fehujs utilitaries (contains file handling, parsing helpers, and id generation)</li> <li>@fehujs/http-server: HTTP server for fehujs projects</li> <li>@fehujs/ioc: IoC container / dependency injection module for fehujs project</li> <li>@fehujs/jeran: Fehujs apps command launcher</li> <li>@fehujs/sessions: Fehujs sessions handling package (only handles session ids yet)</li> <li>@fehujs/template-parser: Small template parser</li> <li>@fehujs/validator: Object validator for requests</li> </ul>"},{"location":"#internal-modules","title":"Internal modules","text":"<p>These modules are internal helpers for Fehujs apps development:</p> <ul> <li>@fehujs/build: Fehujs build utility, it serves to bundle &amp; build the different packages.</li> <li>@fehujs/tsconfig: TS config base for FehuJS projects</li> </ul>"},{"location":"get-started/","title":"Get started","text":""},{"location":"get-started/#installation-and-first-run","title":"Installation and first run","text":"<p>You need to install NodeJS and PNPM.</p> <pre><code>$ npx create-fehujs-app\n\n$ cd myapp  # change with your project name\n\n$ cp .env.example .env  # don't forget to run `node jeran gen-secret-key` one day to generate your secret key\n\n$ node jeran  # start server\n</code></pre> <p>You can now navigate in the docs to learn how to use Fehu's features.</p>"},{"location":"templates/","title":"Templates","text":"<p>There's a list of the official Fehujs templates:</p>"},{"location":"templates/#fehujsstarter-template","title":"fehujs/starter-template","text":"<p>This template is the default one when installing Fehujs with the installer.</p> <p>It is recommended for beginners.</p> <p>GitHub: fehujs/starter-template</p>"},{"location":"templates/#fehujslite-template","title":"fehujs/lite-template","text":"<p>This is an empty template for a Fehujs app, the only configured module is @fehujs/http-server.</p> <p>GitHub: fehujs/lite-template</p>"},{"location":"contribute/","title":"Contribute","text":"<p>You can help this project by starring it on GitHub, and by writing posts about it on your socials.</p> <p>If you want to contribute, there's some features that are missing:</p> <ul> <li>sessions support</li> <li>cache</li> <li>websockets</li> <li>home made database query builder + support for other databases (postresql, mysql,...)</li> <li>api versionning / rest api</li> <li>i18n</li> </ul>"},{"location":"contribute/module-development/","title":"Module development","text":"<p>In the <code>index.ts</code> of the module, you have to specify a config for your module:</p> <pre><code>type YourModuleConfig = { /* your fields here */}\n</code></pre>"},{"location":"modules/auth/","title":"@fehujs/auth","text":"<p>The auth module can handle user authentication with JWT and HTTP cookies.</p> <p>It uses argon2 to hash passwords and jsonwebtoken to generate the authentication tokens.</p>"},{"location":"modules/auth/#module-configuration","title":"Module configuration","text":"<p>There's the list of the config fields, with their default values:</p> <ul> <li><code>TOKEN_COOKIE_NAME: string = \"auth_token\"</code></li> <li><code>TOKEN_COOKIE_EXPIRES: number = 1800000</code></li> <li><code>SALT?: string = undefined</code></li> </ul> <p>You can override them by creating a file <code>./src/config/auth.js</code> which exports an object with the same attributes.</p> <p>General warning about config overriding</p> <p>If you decide to customize the auth module config, please override all of the items.</p> <p>Example:</p> <p>You want to add a salt:</p> <pre><code>export default {\n  TOKEN_COOKIE_NAME = \"auth_token\",  // (1)!\n  TOKEN_COOKIE_EXPIRES = 1800000,\n  SALT = \"my salt\"\n}\n</code></pre> <ol> <li>You need to rewrite the fields that you don't want to change.</li> </ol> <p>Furthermore, you need to be at the root of the project for launching your commands.</p>"},{"location":"modules/auth/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/auth</p> <p>NPM: @fehujs/auth</p> <p>Licence: MIT</p>"},{"location":"modules/auth/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/auth/middleware-and-protecting-routes/","title":"Middleware &amp; protect routes","text":""},{"location":"modules/auth/middleware-and-protecting-routes/#auth-middleware","title":"Auth middleware","text":"<p>Now let's have a look on the Auth middleware (you can learn how does a middleware in the same time):</p> <pre><code>export class AuthMiddleware extends Middleware {\n    public async handle({ req, request, response}: HttpContext) {\n        const user = await User.getCurrentUser(request)\n\n        if (!user) {\n            response = request.cookieHandler.deleteCookie(response, CONFIG.TOKEN_COOKIE_NAME)\n            response = response.redirect(\"/users/login?loginRequired\")\n            return { req, request, response }\n        }\n\n        return super.handle({ req, request, response })\n    }\n}\n</code></pre> <p>So, first, it will try to get the current user. Then, if they doesn't exist, it will destroy the auth token cookie and return a redirection to the login page. If the user exists, the system will call the next middleware or the controller.</p> <p>!!! note title=\"Middlewares\"     In the case where user is undefined, the middleware returns the Http Context instead of calling the next middleware. It's because we don't want that the request continues. If you want to reject a request from a middleware, set a middleware exception or define the response (using <code>response.redirect()</code>, <code>response.setResponse()</code> or <code>response.setErrorResponse()</code>).</p> <pre><code>You can get more informations on the Middleware part of the documentation of the http-server module.\n</code></pre>"},{"location":"modules/auth/middleware-and-protecting-routes/#register-middlewares","title":"Register middlewares","text":"<p>You can register a middleware on a route directly:</p> <pre><code>export const ROUTES: {[key: string]: Route} = {\n    // ...\n    \"GET:/users/dashboard\": {\n        controller: [\"UserController\", \"dashboard\"],\n        middlewares: [\n            new AuthMiddleware()\n        ]\n    }\n    // ...\n}\n</code></pre> <p>You just have to add a middleware list containing all middleware.</p> <p>Note: the middleware will be processed in the same order as they were set:</p> <pre><code>export const ROUTES: {[key: string]: Route} = {\n    // ...\n    \"GET:/users/dashboard\": {\n        controller: [\"UserController\", \"dashboard\"],\n            middlewares: [\n                new AuthMiddleware(),\n                new SomeMiddleware(),\n            ]\n        }\n    }\n    // ...\n}\n</code></pre> <p>In this case, the <code>AuthMiddleware</code> will be called before the <code>SomeMiddleware</code>.</p>"},{"location":"modules/auth/models-and-migrations/","title":"Models &amp; migrations","text":"<p>This module provides build-in migrations and models for users and auth tokens.</p> <p>You can update them by making an inheritance.</p> <p>Note</p> <p>The default provider for these models is <code>SQLDatabaseProvider</code> from the database module. You can update it by inheritance.</p> Default fields <p>The default user model contains: </p> <ul> <li>name</li> <li>email</li> <li>id</li> <li>password </li> </ul> <p>The default auth token model contains:</p> <ul> <li>userId</li> <li>token</li> <li>expiration date</li> <li>id</li> </ul> <p>Now you can register these migrations in ./bin/migrate.ts`:</p> <pre><code>// ...\n\nconst migrations: Record&lt;string, BaseMigration&gt; = {\n    ...(await loadAndInstanciateMigrations()),\n    \"add_user\": new AddUserMigration(),\n    \"add_auth_token\": new AddAuthTokenMigration(),\n}\n//...\n</code></pre> <p>Then run the migrations: <code>node fcli migrate add_auth_token=up add_users=up</code>.</p>"},{"location":"modules/auth/user-login/","title":"User login","text":"<p>There's an example of a login view: <pre><code>    const body = request.body\n    let user: User | null\n\n    // body validation\n\n    try {\n        user = await User.verifyCrendentials(body.email, body.password)\n    } catch (err: any) {\n        // some errors could happen here\n    }\n\n    if (user) {\n        response = await User.login({ request, response }, user)\n        return response.redirect(\"/users/dashboard\")\n    }\n\n    // wrong credentials handling\n</code></pre></p> <p>As you can see, we're using <code>User.login()</code> here as well.</p> <p>Now, let's have a look about <code>User.verifyCredentials()</code>. This method will verify if the password provided by the user matches with the password of the user identified by it's email. The method will return the user if they match, <code>null</code> else.</p>"},{"location":"modules/auth/user-logout/","title":"User logout","text":"<p>Some code from a logout view: <pre><code>    const user = await User.getCurrentUser(request)\n    response = await User.logout({ request, response }, user!) // (1)!\n    return response.redirect(\"/users/login\")\n</code></pre></p> <ol> <li>Here we suppose that this view has the <code>AuthMiddleware</code>.</li> </ol> <p>First of all, we get the current user logged in with the <code>User.getCurrentUser()</code> method (we'll use this method to get the current user if we need them).</p> <p>Then, we call <code>User.logout()</code>, that will suppress the auth token cookie and the token in the database too.</p>"},{"location":"modules/auth/user-registration/","title":"User registration","text":"<p>Here's a demonstration of a view that creates a user: <pre><code>    const body = request.body\n    let user: User | null\n\n    // body validation\n\n    try {\n        user = await User.create({\n            name: body.name,\n            email: body.email,\n            password: body.password\n        }) as User\n    } catch (err: any) {\n        // error handling\n    }\n\n    response = await User.login({ request, response }, user)\n    return response.redirect(\"/users/dashboard\")\n</code></pre></p> <p>Please note that the creation part is quite standart, let's focus on the <code>User.login({ request, response }, user)</code>.</p> <p>This method sets a cookie containing the authentication token after a user login. This cookie will serve to the auth middleware to see if the user is allowed to access to a page (it will get the token out of it and then try to get the user). Furthermore, the token will be stored in the database.</p>"},{"location":"modules/build/","title":"@fehujs/build","text":"<p>Fehujs build utility, it serves to bundle &amp; build the different packages.</p>"},{"location":"modules/build/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/build</p> <p>NPM: @fehujs/build</p> <p>Licence: MIT</p>"},{"location":"modules/build/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/build/usage/","title":"Usage","text":"<p>There's some examples of how we could use this module</p> ./scripts/build.cjs<pre><code>const build = require(\"@fehujs/build\")\n\nbuild()\n</code></pre>"},{"location":"modules/build/usage/#reference","title":"Reference","text":""},{"location":"modules/build/usage/#buildmainpath-srcindexts-tsconfigpath-tsconfigjson","title":"<code>build(mainPath = \"./src/index.ts\", tsconfigPath = \"./tsconfig.json\")</code>","text":"<p>This is the function that bundles and build a TypeScript project.</p> <p>It uses esbuild under the hood.</p>"},{"location":"modules/create-fehujs-app/","title":"create-fehujs-app","text":"<p>Create a Fehujs app.</p>"},{"location":"modules/create-fehujs-app/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/create-fehujs-app</p> <p>NPM: create-fehujs-app</p> <p>Licence: MIT</p>"},{"location":"modules/create-fehujs-app/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/create-fehujs-app/usage/","title":"Usage","text":""},{"location":"modules/create-fehujs-app/usage/#create-a-new-project","title":"Create a new project","text":"<pre><code>npx create-fehujs-app\n</code></pre> <p>The installer will ask you for a project name and a link to a template (Git repository).</p> <p>Note</p> <p>The default template is the fehujs/starter-template.</p>"},{"location":"modules/csrf-shield/","title":"@fehujs/csrf-shield","text":"<p>This module provides a CSRF protection system to secure your forms.</p>"},{"location":"modules/csrf-shield/#module-configuration","title":"Module configuration","text":"<ul> <li><code>TOKEN_COOKIE_NAME: \"csrf_token\"</code></li> <li><code>TOKEN_HEADER_NAME: \"x-csrf-token\"</code></li> <li><code>TOKEN_BODY_NAME: \"_token\"</code></li> <li><code>TOKEN_EXPIRES: \"300000\"</code></li> </ul>"},{"location":"modules/csrf-shield/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/csrf-shield</p> <p>NPM: @fehujs/csrf-shield</p> <p>Licence: MIT</p>"},{"location":"modules/csrf-shield/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/csrf-shield/protect-routes/","title":"Protect an endpoint","text":"<p>First, you need to create the routes (for this example, we'll create a create post endpoint).</p> <p>You need a GET endpoint (<code>PostController.create()</code>) to display the form and a POST (<code>PostController.processCreate()</code>) to handle the request.</p> <p>Register the <code>CsrfValidationMiddleware</code> on your post endpoint: <pre><code>    //...\n    middlewares: [new CsrfMiddleware()]\n    //...\n</code></pre></p> <p>In your controller: <pre><code>    public async create({ request, response }: HttpContext) {\n        const csrfToken = response.generateCsrfToken(request)\n        response = response.setCsrfCookie({ request, response }, csrfToken)\n\n        return response.setResponse({\n            contentType: \"text/html\",\n            body: render(\"./src/templates/path/to/template.html\", {\n                csrfInput: response.csrfHTMLInput(csrfToken)\n            })\n        })\n    }\n\n    public async processCreate({ request, response }: HttpContext) {\n        // ...\n    }\n</code></pre></p> <p>In the template: <pre><code>    &lt;!-- ... --&gt;\n\n    &lt;form action=\"#\" method=\"post\"&gt;\n        {{csrfInput}}\n\n        &lt;!-- ... --&gt;\n    &lt;/form&gt;\n\n    &lt;!-- ... --&gt;\n</code></pre></p> <p>What's happening in this example?</p> <p>First, the user will load the form, and the server will add a little hidden input contening the token in the form.</p> <p>When the user submits the form, the <code>CsrfMiddleware</code> gets the token and verifies it. If the token isn't defined or the token is invalid (doesn't matches with the request id csrf token or it is expired), a 403 page expired exception is raised.</p> <p>If the token is valid, the process continues.</p>"},{"location":"modules/database/","title":"@fehujs/database","text":"<p>This module permits you to interact with a database, to handle your migrations and your models.</p> <p>For now on, only the SQLite database provider is implemented, but you can implement other providers on your own using the API (more info at the bottom of this file).</p> <p>It uses Knex under the hood, but maybe we'll create a homemade SQL query builder (one day).</p> <p>Please note that foreign keys aren't planned to be implemented. If you want to link two tables create a field in the first one that contains the second table primary key.</p> <p>DISCLAIMER: some features are not fully available or tested (alter table, findByWithSQL, SQL injection avoider), please consider test them yourselves before using these features.</p> <p>Note: you can install the SQLite Viewer VS code extension (from Florian Klampfer) to view your database directly from the IDE.</p>"},{"location":"modules/database/#module-configuration","title":"Module configuration","text":"<ul> <li><code>NAME: \"database.sqlite\"</code></li> <li><code>PATH: \"database.sqlite\"</code></li> <li><code>PROVIDER: \"sqlite\"</code></li> <li><code>CONFIG</code> (config is an object with the following properties):<ul> <li><code>user: 'localhost'</code></li> <li><code>host: 'localhost'</code></li> <li><code>database: \"database.db\"</code></li> <li><code>password: \"\"</code></li> <li><code>port: 5432</code></li> </ul> </li> </ul>"},{"location":"modules/database/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/database</p> <p>NPM: @fehujs/database</p> <p>Licence: MIT</p>"},{"location":"modules/database/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/database/migrations/","title":"Migrations","text":"<p>The migrations can help you to define the tables of your database.</p>"},{"location":"modules/database/migrations/#create-a-migration","title":"Create a migration","text":"<p>You have to create a new file in the <code>src/db/migrations</code> directory. For this example we will create a Post migration.</p> <p>So, here's my migration:</p> add-post.ts<pre><code>import { BaseMigration, provider, Table } from \"@fehujs/database\"\n\nexport class AddPostMigration extends BaseMigration {\n    readonly name = \"add_post\"\n\n    protected table = {\n        name: \"posts\",\n        columns: [\n        ]\n    }\n\n    public async up() {\n    }\n\n    public async down() {\n    }\n}\n</code></pre>"},{"location":"modules/database/migrations/#define-tables","title":"Define tables","text":"<p>To define tables, you have to put columns into your table. Watch out:</p> add-post.ts<pre><code>// ...\n\nexport class AddPostMigration extends BaseMigration {\n    readonly name = \"add_post\"\n\n    protected table = {\n        name: \"posts\",\n        columns: [\n            {\n                name: 'id',\n                type: 'INTEGER',\n                isNotNull: true,\n                isPrimaryKey: true,\n                isUnique: true,\n                // isAutoincrement: true  (1)\n            },\n            {\n                name: 'title',\n                type: 'TEXT',\n                isNotNull: true\n            },\n            {\n                name: 'content',\n                type: 'TEXT',\n                isNotNull: true,\n            }\n        ]\n    }\n\n    // ...\n</code></pre> <ol> <li>Nota: I won't use autoincrement to handle ids in this example</li> </ol> <p>Nota: here's the column typing: <pre><code>type Column = {\n    name: string\n    /** type of the contained value */\n    type: 'TEXT' | 'INTEGER' | 'NULL' | 'REAL' | 'BLOB'\n    default?: string\n    isAutoIncrement?: boolean\n    isNotNull?: boolean\n    isPrimaryKey?: boolean\n    isUnique?: boolean\n}\n</code></pre></p> <p>Don't forget to create the <code>up()</code> and <code>down()</code> methods, the first one to set the migration up, and the second to cancel it.</p> <pre><code>import provider from \"../providers\" // (1)!\n\n    // ...\n    public async up() {\n        await provider.createTable(this.table)\n    }\n\n    public async down() {\n        await provider.dropTable(this.tableName)\n    }\n</code></pre> <ol> <li>You need to export the instance of the database provider in <code>./src/db/providers/index.js</code></li> </ol> <p>About database providers</p> ./src/db/providers/index.js<pre><code>import { SQLiteDatabaseProvider } from \"@fehujs/database\"\n\nexport const provider = new SQLiteDatabaseProvider()\n</code></pre> <p>In the <code>providers</code> directory you can implement others providers for other types of databases. But don't forget to update the provider's name in the database config.</p>"},{"location":"modules/database/migrations/#drop","title":"Drop","text":"<p>You can drop a table using <code>await provider.dropTable(this.tableName)</code>.</p>"},{"location":"modules/database/migrations/#run-migrations","title":"Run migrations","text":"<p>Now we finished implementing your migration, we want to run it.</p> <p>If your migration is located in <code>./src/db/migrations</code>, it will be registered automatically.</p> <p>Otherwise, you'll need to import the class and to instanciate manually:</p> ./bin/migrate.ts<pre><code>import { AddPostMigration } from \"./add_post\"\n\nconst migrations: Record&lt;string, BaseMigration&gt; = {\n    ...(await loadAndInstanciateMigrations()),\n    \"add_post\": new AddPostMigration(),\n}\n//...\n</code></pre> <p>Then you can run the migration: <code>node fcli migrate</code>.</p> <p>Nota: flags.</p> <p>You can specify the migration key (from the migrations object from <code>./bin/migrate.ts</code>), and set it on up if you want to run this migration.</p> <p>Example (in this case): <code>node fcli migrate add_post=up</code>, but you can put <code>add_post=down</code>. If it isn't specified, nothing happends.</p> <p>If you don't put any flag, all registred migrations that were not runned (their names aren't situated in the migrations.json at the root of the project) will be runned (mode up). If you specify a key, only the migration.s specified will be executed.</p>"},{"location":"modules/database/migrations/#alter-table","title":"Alter table","text":"<p>This isn't implemented.</p>"},{"location":"modules/database/models/","title":"Models","text":"<p>Models are the objects that permit you to handle and store data during a request.</p>"},{"location":"modules/database/models/#create-a-model","title":"Create a model","text":"<p>You need to create a directory named <code>src/app/models</code> and you create a new file containing your model in it.</p> <p>Example: </p> post.ts<pre><code>import { BaseModel } from \"@fehujs/database\"\n\nimport { AddPostMigration } from \"../../db/migrations/add_post\"\n\nexport class Post extends BaseModel {\n    public static table = (new AddPostMigration()).getTable()  // this is to avoid the rewriting of the table\n\n    // if your (main) private key isn't 'id', change it there\n    protected idCol: string = 'your_main_private_key_column_name'\n\n    // don't forget to declare the fields in the model\n    declare id: string\n\n    declare title: string\n\n    declare content: string\n}\n</code></pre> <p>Please note that you can override every method of BaseModel if you need something more complex (you can see an example in the Auth module).</p>"},{"location":"modules/database/models/#get","title":"Get","text":"<p>There's many ways to get datas from database with this system.</p>"},{"location":"modules/database/models/#modelfindid-string-number-promisebasemodel-static","title":"<code>Model.find(id: string | number): Promise&lt;BaseModel&gt;</code> (static)","text":"<p>You can get an item with its primary key.</p>"},{"location":"modules/database/models/#modelfindbykey-string-value-string-operator-operator-promisebasemodel-static","title":"<code>Model.findBy(key: string, value: string, operator: Operator = '='): Promise&lt;BaseModel[]&gt;</code> (static)","text":"<p>You can get many items using this function (key param stands for the column name, the value stands for the value to be compared, and the operator stands for the operation between key and the value)</p>"},{"location":"modules/database/models/#modelfindwithsqlcondition-string-promisebasemodel-static-depreciated","title":"<code>Model.findWithSql(condition: string): Promise&lt;BaseModel[]&gt;</code> (static) (depreciated)","text":"<p>Supposed to return an array of models selected with a SQL selection, <code>condition</code>.</p> <p>depreciated</p> <p>Use instead <code>provider.query()</code> (returns an instance of Knex).</p>"},{"location":"modules/database/models/#modelfindall-promisebasemodel-static","title":"<code>Model.findAll(): Promise&lt;BaseModel[]&gt;</code> (static)","text":"<p>Returns all items of a table.</p>"},{"location":"modules/database/models/#create","title":"Create","text":""},{"location":"modules/database/models/#modelcreateoptions-modelobject-promisebasemodel-static","title":"<code>Model.create(options: ModelObject): Promise&lt;BaseModel&gt;</code> (static)","text":"<p>Creates a new object in the database and returns it.</p>"},{"location":"modules/database/models/#editsave","title":"Edit/save","text":""},{"location":"modules/database/models/#instancesave-promisevoid","title":"<code>instance.save(): Promise&lt;void&gt;</code>","text":"<p>Let's have a demo:</p> <pre><code>    const post = new Post()\n    post.id = \"....\"\n    post.title = \"hello there\"\n    post.content = \".\"\n\n    // right now my model (\"post\") isn't stocked in the db\n\n    post.save()\n\n    // now it is\n\n    post.content = \"new content\" // (1)!\n\n    post.save() // (2)!\n</code></pre> <ol> <li>the update isn't stored in the db, but the new value is stocked in the model's data</li> <li>the changes have been stocked in the db</li> </ol>"},{"location":"modules/database/models/#delete","title":"Delete","text":""},{"location":"modules/database/models/#instancedestroy-promisevoid","title":"<code>instance.destroy(): Promise&lt;void&gt;</code>","text":"<p>Destroys the item specified.</p>"},{"location":"modules/database/models/#format-data","title":"Format data","text":""},{"location":"modules/database/models/#instancetoobject-modelobject","title":"<code>instance.toObject(): ModelObject</code>","text":"<p>Returns the model data stocked in model.data, not the data from db (the difference is that the model.data may be different than db because it stores values updates before saving in the db).</p>"},{"location":"modules/database/models/#instancetojson-string","title":"<code>instance.toJson(): string</code>","text":"<p>Returns the model data stocked in model.data as JSON.</p>"},{"location":"modules/database/models/#serializing","title":"Serializing","text":""},{"location":"modules/database/models/#instanceserializefields-serialize-modelobject-undefined","title":"<code>instance.serialize(fields: Serialize): ModelObject | undefined</code>","text":"<p>Serializes the model according to provided fields.</p> <p>This is the typing of fields: <pre><code>type Serialize = {\n    [keys: string]: {\n        serializeAs?: string\n        doSerialize?: (value: string | number) =&gt; string\n    }\n}\n</code></pre></p> <p>There's a little example: <pre><code>const posts = await Post.findAll() as Post[]\n\nconst postsSerialized: ModelObject[] = await new Promise((resolve, reject) =&gt; {\n    let serialized: ModelObject[] = []\n\n    posts.forEach(async post =&gt; {\n        const postSerialized = post.serialize({\n            id: {\n                serializeAs: \"postId\"\n            },\n            title: {\n                doSerialize: (value: string | number) =&gt; `${value.toString().slice(0, 10)}...`\n            }\n        })\n        serialized.push(postSerialized!)\n    })\n\n    resolve(serialized)\n})\n</code></pre></p>"},{"location":"modules/database/provider-api/","title":"Usage of the providers' API","text":"<p>You might need to use the providers' API without models to create complex requests to your database, or for implementing new providers for other database types.</p> <p>The databases providers are implementing <code>DatabaseProviderInterface</code>:</p>"},{"location":"modules/database/provider-api/#connectdbdbpath-string-void","title":"<code>connectDb(dbPath: string): void</code>","text":"<p>Connect the DB for interaction.</p>"},{"location":"modules/database/provider-api/#closeconnection-void","title":"<code>closeConnection(): void</code>","text":"<p>Closes the connection after transaction.</p>"},{"location":"modules/database/provider-api/#get-db-any-undefined","title":"<code>get db(): any | undefined</code>","text":"<p>Returns the DB object.</p>"},{"location":"modules/database/provider-api/#get-dbpath-string","title":"<code>get dbPath(): string</code>","text":"<p>Returns the DB path.</p>"},{"location":"modules/database/provider-api/#createtable-table-createtable-promisevoid","title":"<code>createTable: (table: CreateTable) =&gt; Promise&lt;void&gt;</code>","text":"<p>Permits to create a new table.</p>"},{"location":"modules/database/provider-api/#altertable-table-altertable-promisevoid","title":"<code>alterTable: (table: AlterTable) =&gt; Promise&lt;void&gt;</code>","text":"<p>Permits to alter a table, usefull for migrations.</p> <p>Warning</p> <p><code>SQLiteDatabaseProvider</code>: not implemented yet.</p>"},{"location":"modules/database/provider-api/#droptable-table-table-promisevoid","title":"<code>dropTable: (table: Table) =&gt; Promise&lt;void&gt;</code>","text":"<p>Drops a table.</p>"},{"location":"modules/database/provider-api/#async-queryt-extends-modelobjecttable-table","title":"<code>async query&lt;T extends ModelObject&gt;(table: Table)</code>","text":"<p>Returns a query builder.</p> <p>Note</p> <p><code>SQLiteDatabaseProvider</code> returns a new <code>Knex</code> instance.</p>"},{"location":"modules/database/provider-api/#select-t-extends-modelobject-table-table-condition-any-promiset","title":"<code>select &lt;T extends ModelObject&gt; (table: Table, condition?: any): Promise&lt;T[]&gt;</code>","text":"<p>Runs a select query.</p> <p>Tip</p> <p>If you want to select all columns, don't set the them on the <code>table</code> argument.</p> <p>Example:</p> <p>We have a <code>posts</code> table with these columns: <code>id</code>, <code>title</code>, <code>content</code>.</p> <p>If we want to get all these columns, you can do : <pre><code>    const posts = await provider.select((new AddPostsMigration()).getTable(), \"..\") // get the cols directly specifying the table\n\n    // OR\n\n    const posts = await provider.select({ name: \"posts\" }, \"...\")  // create a \"new table\" with only the name\n</code></pre></p>"},{"location":"modules/database/provider-api/#insert-t-extends-modelobject-table-table-value-t-promiset","title":"<code>insert &lt;T extends ModelObject&gt; (table: Table, value: T): Promise&lt;T&gt;</code>","text":"<p>Runs an insert query.</p>"},{"location":"modules/database/provider-api/#update-t-extends-modelobject-table-table-condition-any-value-t-promiset","title":"<code>update &lt;T extends ModelObject&gt; (table: Table, condition: any, value: T): Promise&lt;T&gt;</code>","text":"<p>Runs an update query.</p> <p>Note</p> <p>Same remark as <code>select</code>.</p>"},{"location":"modules/database/provider-api/#delete-t-extends-modelobject-table-table-condition-any-promiset","title":"<code>delete &lt;T extends ModelObject&gt; (table: Table, condition: any): Promise&lt;T[]&gt;</code>","text":"<p>Runs an delete query.</p> <p>Note</p> <p>Same remark as <code>select</code> and <code>update</code>.</p>"},{"location":"modules/database/seeders/","title":"Seeders","text":"<p>You can create seeders if you want to create items automatically.</p> <p>Let's create a file <code>post.ts</code> in the directory named <code>src/app/seeders</code>.</p> ./src/db/seeders/post.ts<pre><code>import { BaseSeeder } from \"@fehujs/database\"\nimport { Post } from \"../../app/models/post\"\n\n\nexport class PostSeeder extends BaseSeeder {\n    readonly name = \"create_initial_post\"\n\n    public async run() {\n        await Post.create({\n            id: Date.now(),\n            title: \"created by seeder\",\n            content: \"this is a post created by the seeder\"\n        })\n    }\n}\n</code></pre> <p>Now, register the seeder (as for migrations, if your seeder is located in <code>./src/db/seeders</code>, it will be loaded automatically), otherwise:</p> <pre><code>// ...\n\nconst seeders: Record&lt;string, BaseSeeder&gt; = {\n    ...await loadAndInstanciateSeeders(),\n    \"create_initial_post\": new PostSeeder()\n}\n// ...\n</code></pre> <p>Then run <code>node fcli seeders create_initial_post</code>.</p> <p>Note</p> <p>You must specify the seeder key to run the seeder.</p>"},{"location":"modules/helpers/","title":"@fehujs/helpers","text":"<p>Fehujs helpers package contains contains file handling, parsing helpers, and id generation with paralleldrive/cuid2.</p>"},{"location":"modules/helpers/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/helpers</p> <p>NPM: @fehujs/helpers</p> <p>Licence: MIT</p>"},{"location":"modules/helpers/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/helpers/files/","title":"File handling","text":""},{"location":"modules/helpers/files/#getfilefilename-string-promisebufferarraybufferlike","title":"<code>getFile(filename: string): Promise&lt;Buffer&lt;ArrayBufferLike&gt;&gt;</code>","text":"<p>Get the content of a file, depending on it's path.</p>"},{"location":"modules/helpers/files/#getfilefromtmpfilename-string-promisebufferarraybufferlike","title":"<code>getFileFromTmp(filename: string): Promise&lt;Buffer&lt;ArrayBufferLike&gt;&gt;</code>","text":"<p>Get the content of a file stored in tmp storage.</p>"},{"location":"modules/helpers/files/#getfileformatfilename-string-promisestring","title":"<code>getFileFormat(filename: string): Promise&lt;string&gt;</code>","text":"<p>Get the format of a file depending on it's extension.</p> <p>Note</p> <p>This function parses the file <code>./src/content-types.json</code> that contains a set of a lot of extensions with their content type.</p> <p>You can add as many as you want.</p> <p>If a file extension isn't registered in this set, the default is set to <code>text/plain</code>.</p>"},{"location":"modules/helpers/files/#fileexistsfilename-string-promiseboolean","title":"<code>fileExists(filename: string): Promise&lt;boolean&gt;</code>","text":"<p>Check if a file exists.</p>"},{"location":"modules/helpers/files/#movefilepath-string-newpath-string-options-overwrite-boolean-overwrite-false-promisevoid","title":"<code>move(filepath: string, newPath: string, options: { overwrite: boolean } = { overwrite: false }): Promise&lt;void&gt;</code>","text":"<p>Moves the file <code>filepath</code> to a the <code>newPath</code> directory.</p> <p>If <code>options.overwrite</code> is <code>true</code>, if a file A has the same name in the destination directory, A will be replaced by the other one. Otherwise, an error is raised.</p>"},{"location":"modules/helpers/id-generation/","title":"Id generation","text":""},{"location":"modules/helpers/id-generation/#randomidprefix-string-string","title":"<code>randomId(prefix?: string): string</code>","text":"<p>It uses paralleldrive/cuid2 under the hood.</p> <p>If <code>prefix</code> is set, it will return <code>\"&lt;prefix&gt;_&lt;id&gt;</code>, otherwise it will return only the generated id.</p>"},{"location":"modules/helpers/parsing/","title":"Parsing","text":""},{"location":"modules/helpers/parsing/#parsebasedelimiter1-string-delimiter2-string-raw-string-recordstring-string","title":"<code>parseBase(delimiter1: string, delimiter2: string, raw: string): Record&lt;string, string&gt; {</code>","text":"<p>This function is the base for all data type that can be parsed by splitting only two times a string, like cookies or request body.</p> <p>Example:</p> <pre><code>key1=val&amp;key2=val2&amp;...&amp;keyN=valN\n</code></pre> <p>Here, the first delimiter would be \"&amp;\" because it delimits couples key-value, the second one would be \"=\" because it delimits keys from values.</p>"},{"location":"modules/helpers/parsing/#parsecookiedataraw-string-undefined-recordstring-string","title":"<code>parseCookieData(raw: string | undefined): Record&lt;string, string&gt;</code>","text":"<p>Helper calling <code>parseBase</code> for request's cookies parsing.</p> <p>In this case, we have a <code>raw</code> like this:</p> <pre><code>cookie1=value1;cookie2=value2\n</code></pre>"},{"location":"modules/http-server/","title":"@fehujs/http-server","text":"<p>This module contains the main features of a http server. It could be considered as the main module of the Fehujs project.</p>"},{"location":"modules/http-server/#module-configuration","title":"Module configuration","text":"<p>You'll need to create a <code>NODE_ENV</code> variable in your <code>.env</code> file. This will tell to the package in which context we are running the application.</p> <p>Note</p> <p>The only modes allowed are \"dev\", \"test\" or \"production\".</p> <p>If the mode isn't one of these, the \"dev\" will be set by default.</p> <p>Furthermore, this is the others fields: - <code>port: 3000</code> - <code>form</code>:     - <code>formOptions</code>:         - <code>encoding: \"utf-8\"</code>         - <code>keepExtensions: true</code>         - <code>uploadDir: \"tmp/uploads\"</code>     - <code>errorHandler</code>: <code>(err: any): any | undefined</code> (default is <code>undefined</code>) - <code>https: { key: string, cert: string } | undefined</code> (default is <code>undefined</code>)</p> <p>HTTPS</p> <p>More information about HTTPS config on this page.</p> <p>Bug</p> <p>Please avoid importing modules into config files, because actually the config fetching doesn't support it (it doesn't support too long import promises).</p> <p>You can also, in <code>./src/config/global-middlewares.js</code>, configure a list of all the middlewares to execute before all the views.</p>"},{"location":"modules/http-server/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/http-server</p> <p>NPM: @fehujs/http-server</p> <p>Licence: MIT</p>"},{"location":"modules/http-server/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/http-server/assets/","title":"Assets","text":""},{"location":"modules/http-server/assets/#public-directory","title":"<code>public</code> directory","text":"<p>All files contained in the public directory will be registered as GET endpoints by the server thanks to the Assets Helper on the server startup.</p> <p>The endpoint url will be the relative path of the file from <code>./src/public</code>.</p> <p>If the file extension isn't in the <code>./src/content-types.json</code> file, please add it yourself (it will be served as plain text otherwise).</p>"},{"location":"modules/http-server/cookies/","title":"Cookies","text":"<p>The <code>Request</code> class has a <code>cookieHandler</code> property which returns a <code>CookieHandler</code>.</p> <p>You won't need to create an instance yourself (as for <code>Request</code> or <code>Response</code>).</p>"},{"location":"modules/http-server/cookies/#getcookies-recordstring-string","title":"<code>getCookies(): Record&lt;string, string&gt;</code>","text":"<p>Get all the cookies from the response.</p>"},{"location":"modules/http-server/cookies/#getcookiename-string-string","title":"<code>getCookie(name: string): string</code>","text":"<p>Get the value of the specified cookie.</p>"},{"location":"modules/http-server/cookies/#setcookieresponse-response-cookie-cookie-response","title":"<code>setCookie(response: Response, cookie: Cookie): Response</code>","text":"<p>Creates a cookie. </p> <p>Warning</p> <p>This method adds a header in the response, so you need to assign the new headers on your response.</p> <p>E.g: <code>response = request.cookieHandler.setCookie(response, cookie)</code></p> This is the type of a cookie<pre><code>export type Cookie = {\n    name: string\n    value: string\n    domain?: string\n    expires?: string\n    httpOnly?: boolean\n    maxAge?: number\n    partitioned?: boolean\n    path?: string\n    secure?: boolean\n    sameSite?: \"Strict\" | \"Lax\" | \"None\"\n}\n</code></pre>"},{"location":"modules/http-server/cookies/#deletecookieresponse-response-name-string-response","title":"<code>deleteCookie(response: Response, name: string): Response</code>","text":"<p>Deletes a cookie.</p> <p>Warning</p> <p>This method adds a header in the response, so you need to assign the new headers on your response.</p> <p>E.g: <code>response = request.cookieHandler.deleteCookie(response, cookieName)</code></p>"},{"location":"modules/http-server/http-context/","title":"Http context","text":"<p>The http context is an object containing the response and the request during the request travel into our server. It's created when the server get receive the request, and the response is what you'll return to the client.</p> <p>It contains a optional <code>req</code> instance that is the request from Node HTTP module, which is an <code>IncomingMessage</code>, for more informations, please refer to the official Nodejs documentation.</p>"},{"location":"modules/http-server/http-context/#request","title":"Request","text":"<p>You can create a new instance (if you want) by calling the <code>Request.init()</code> static method, but the server creates it automatically.</p> <p>This class has a lot of getters that permits you to access to the request data. See the implementation for more infos.</p>"},{"location":"modules/http-server/http-context/#response","title":"Response","text":"<p>The response is what you'll send to the client, so you need to know how it works.</p> <p>The server creates it automatically like Request, and your \"job\" is to find what you have to put in it.</p> <p>There's a lot of getters and setters on this class, see the implementation for more infos.</p>"},{"location":"modules/http-server/https/","title":"HTTPS","text":"<p>You need to have OpenSSL installed.</p> <p>Then run:</p> <pre><code>openssl genpkey -algorithm RSA -out ./tmp/private-key.pem \nopenssl req -new -key ./tmp/private-key.pem -out ./tmp/csr.pem\nopenssl x509 -req -days 365 -in ./tmp/csr.pem -signkey ./tmp/private-key.pem -out ./tmp/certificate.pem\n</code></pre> <p>Cf. A Detailed look into the Node.js HTTP module, by Mirza Leka.</p> <p>Then put your private key file's and certificate file's paths in your http config file.</p> <pre><code>    // ...\n\n    https: {\n        key: 'tmp/private-key.pem',\n        cert: 'tmp/certificate.pem',\n    },\n\n    // ...\n</code></pre> <p>The project will start two servers, the one on HTTPS and the second in HTTP that will do the redirections to the HTTPS one.</p>"},{"location":"modules/http-server/middlewares/","title":"Middlewares","text":"<p>Middlewares are methods that are executed before the route code and permits to do some checks about the request.</p> <p>If you want to know if a user is logged in or not, you'll need to implement a middleware (I mean, you can do this in a controller but it's not as clean as with middlewares because you might use the same code in other routes etc...).</p> <p>You can create a file at <code>src/app/middlewares</code> and type this code in the the file:</p> <p>for example: <pre><code>import { Middleware, HttpContext } from \"@fehujs/http-server\"\n\n\nexport class MyMiddleware extends Middleware {\n    public async handle(httpContext: HttpContext) {\n        console.log(\"my middleware\")\n        return super.handle(httpContext)\n    }\n}\n</code></pre></p> <p>The <code>super.handle()</code> intruction will call the next middleware or return the output Http context at the end of middleware execution process (you can edit the <code>request</code> in the middlewares).</p> <p>Now you can register it in routes (cf. Route page).</p> <p>If the '/' route is called, the middleware will be runned before the route code and the middleware can decide if the process continues or no.</p> <p>There's an example of a middleware that decides to return the response right after it's execution:</p> <pre><code>export class TestMiddleware extends Middleware {\n    public async handle(httpContext: HttpContext) {\n        console.log(\"authorization middleware\")\n        const isAuthorized = false  // this is only an example\n\n        if (isAuthorized) {\n            return super.handle(httpContext)\n        }\n\n        httpContext.response.setErrorResponse({\n            statusCode: 403,\n            statusMessage: \"Unauthorized\"\n        })\n        return httpContext\n    }\n}\n</code></pre> <p>Note</p> <p>In the case where <code>isAuthorized</code> is false, we define a response that will be returned directly after the calling of this middleware because we return the Http context and not the next middleware.</p> <p>Warning</p> <p>Please note that in the \"middleware\" response context (aka when the middlewares are processed), if you call the response's methods <code>redirect</code>, <code>setResponse</code> or <code>setErrorRespone</code>, the view after the middleware won't be runned and the response from the last runned middleware will be send to the client.</p> <p>You can also do the last example using <code>MiddlewareError</code>:</p> <pre><code>export class TestMiddleware extends Middleware {\n    public async handle(httpContext: HttpContext) {\n        console.log(\"authorization middleware\")\n        const isAuthorized = false\n\n        if (isAuthorized) {\n            return super.handle(httpContext)\n        }\n\n        throw new MiddlewareError(403, \"Not authorized\", \"Unauthorized\")\n    }\n}\n</code></pre> <p>The <code>MiddlewareError</code> will be catched and it will return the response specified in the exception: - responseStatus: should be an error HTTP status code - responseMsg: the body of the error response - message: the error description - contentType: default = \"text/html\"</p>"},{"location":"modules/http-server/router/","title":"Router","text":"<p>There are the reference of the router helpers functions.</p>"},{"location":"modules/http-server/router/#patterntoregexpattern-string-regexp","title":"<code>patternToRegex(pattern: string): RegExp</code>","text":"<p>This fucntion permits to convert a route pattern into a regex, which will be used for the route identification at request receiving.</p>"},{"location":"modules/http-server/router/#extractrouteparamsmatch-regexpmatcharray-pattern-string-routeparams","title":"<code>extractRouteParams(match: RegExpMatchArray, pattern: string): RouteParams</code>","text":"<p>This function extracts the params of a route with params depending on its regex.</p>"},{"location":"modules/http-server/routing/","title":"Routing","text":""},{"location":"modules/http-server/routing/#create-a-new-route","title":"Create a new route","text":"<p>You can add a new item in the <code>ROUTES</code> object of <code>src/app/routes.ts</code>:</p> <pre><code>export const ROUTES = {\n    \"GET:/\": {\n        callback: async ({ response }: HttpContext) =&gt; {\n            return response.setResponse({\n                contentType: \"text/html\",\n                body: await readFile(\"./src/templates/index.html\", \"utf8\")\n            })\n        },\n    },\n}\n</code></pre> <p>As you can see, the key is the endpoint of the route (if a GET request on '/' is detected, the specified callback will be called).</p> <p>The callback takes a <code>HttpContext</code> parameter, and must return a <code>Response</code>. These are needed to achieve the request path into our system, from the receiving to the response sending.</p> <p>If we can, we can add middlewares and route description:</p> <pre><code>export const ROUTES = {\n    \"GET:/\": {\n        callback: async ({ response }: HttpContext) =&gt; {\n            return response.setResponse({\n                contentType: \"text/html\",\n                body: await readFile(\"./src/templates/index.html\", \"utf8\")\n            })\n        },\n        middlewares: [ new MyMiddleware() ],\n        description: 'This is the homepage',\n    },\n}\n</code></pre>"},{"location":"modules/http-server/routing/#routes-with-params","title":"Routes with params","text":"<p>You can specify a parameter by writing <code>:&lt;param name&gt;</code> in the url, like in the examples below:</p> <pre><code>    \"GET:/hello/:name\": {\n        callback: async ({ request, response }: HttpContext) =&gt; {\n            return response.setResponse({\n                contentType: \"text/html\",\n                body: `Hello ${request.params.name}`\n            })\n        }\n    },\n    \"GET:/hello/:name/:hi\": {\n        callback: async ({ request, response }: HttpContext) =&gt; {\n            return response.setResponse({\n                contentType: \"text/html\",\n                body: `Hello ${request.params.name} ${request.params.hi}`\n            })\n        }\n    },\n</code></pre> <p>If you want to access to those params in the controller, you can get them from <code>request.params.&lt;param&gt;</code>.</p> <p>Bug</p> <p>You cannot have two params between two <code>/</code>.</p> <p>E.g: this <code>/post/:slug-:id</code> won't work. Instead do <code>post/:slug/:id</code>.</p>"},{"location":"modules/http-server/routing/#controllers","title":"Controllers","text":"<p>You can create controllers to split the code in many files.</p> <pre><code>export class CoreController extends BaseController {\n    public async home({ response }: HttpContext) {\n        return response.setResponse({\n            contentType: \"text/html\",\n            body: await readFile(\"./src/templates/index.html\", \"utf8\")\n        })\n    }\n}\n</code></pre> <p>And then your route is like this:</p> <pre><code>\"GET:/\": {\n    controller: [\"CoreController\", \"home\"],\n    middlewares: [ new MyMiddleware() ],\n    description: 'This is the homepage',\n},\n</code></pre>"},{"location":"modules/http-server/routing/#list-routes","title":"List routes","text":"<p>If you want to list all the existing routes, you can run the command <code>node fcli list-routes</code>.</p>"},{"location":"modules/http-server/server/","title":"Server","text":"<p>There are the reference of the server helpers functions.</p>"},{"location":"modules/http-server/server/#getendpointroutes-routes-method-string-undefined-request-request-string","title":"<code>getEndpoint(routes: Routes, method: string | undefined, request: Request): string</code>","text":"<p>Identifies the route depending on the request url.</p>"},{"location":"modules/http-server/server/#requestlisteneroptions-requestlisteneroptions-promisevoid","title":"<code>requestListener(options: RequestListenerOptions): Promise&lt;void&gt;</code>","text":"<p>This is the function that will be called when the server receive a request.</p>"},{"location":"modules/http-server/server/#runcontrollerhttpcontext-httpcontext-controllers-controllers-controller-string-string-args-any-promiseresponse","title":"<code>runController(httpContext: HttpContext, controllers: Controllers, controller: [string, string], args?: any): Promise&lt;Response&gt;</code>","text":"<p>Run a controller depending on it's declaration in the route object: <code>[\"ControllerName\", \"methodName\"]</code>.</p>"},{"location":"modules/http-server/server/#runmiddlewareshttpcontext-httpcontext-route-route","title":"<code>runMiddlewares(httpContext: HttpContext, route: Route)</code>","text":"<p>Runs all the middlewares of the route.</p>"},{"location":"modules/http-server/server/#runviewhttpcontext-httpcontext-controllers-controllers-route-route-promiseresponse","title":"<code>runView(httpContext: HttpContext, controllers: Controllers, route: Route): Promise&lt;Response&gt;</code>","text":"<p>Runs a view/route, if \"controller\" is defined, it will call <code>runController</code>, otherwise it will call the \"callback\".</p>"},{"location":"modules/http-server/server/#setupcontrollers-promiserecordstring-basecontroller","title":"<code>setupControllers(): Promise&lt;Record&lt;string, BaseController&gt;&gt;</code>","text":"<p>Instanciate and resolve dependencies injections of all the controllers defined (in <code>./src/app:controllers</code> and <code>ErrorsController</code>).</p>"},{"location":"modules/http-server/server/#setuproutesroutes-routes-globalmiddlewares-typeof-middleware-routes","title":"<code>setupRoutes(routes: Routes, globalMiddlewares: (typeof Middleware)[]): Routes</code>","text":"<p>Setup routes:</p> <ul> <li>create the regex of the endpiont pattern.</li> <li>instanciate the global middlewares and the route middlewares.</li> </ul>"},{"location":"modules/ioc/","title":"@fehujs/ioc","text":"<p>IoC container / dependency injection module for fehujs project.</p>"},{"location":"modules/ioc/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/ioc</p> <p>NPM: @fehujs/ioc</p> <p>Licence: MIT</p>"},{"location":"modules/ioc/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/ioc/dependency-injection/","title":"Dependency injection","text":"<p>If you want to use Dependency injection for your services, you can by defining your services in <code>src/app/services</code>:</p> <pre><code>import { Injectable } from \"@fehujs/ioc\"\n\n@Injectable()\nexport class MyService extends BaseService {\n    getData() {\n        return { data: \"my data\" }\n    }\n}\n</code></pre> <p>The <code>Injectable</code> decorator permits to define a class that could be injected.</p> <p>Then in your controller:</p> <pre><code>import { Inject } from \"@fehujs/ioc\"\n\nexport class TestDIController extends BaseController {\n    constructor(@Inject(MyService) protected myService: MyService) {\n        super()\n    }\n\n    myView({ response }: HttpContext) {\n        return response.setResponse({\n            body: JSON.stringify(this.myService.getData()),\n            contentType: \"application/json\"\n        })\n    }\n}\n</code></pre> <p>The <code>Inject</code> decorator defines a dependency of the class.</p> <p>You can register the views like all controllers.</p> <p>Tip</p> <p>You can inject services into services:</p> <pre><code>@Injectable()\nexport class SecondService extends BaseService {\n    getData() {\n        return \"hello, world\"\n    }\n}\n\n@Injectable()\nexport class FirstService extends BaseService {\n    constructor(@Inject(SecondService) protected secondService: SecondService) {\n        super()\n    }\n\n    getData() {\n        return { data: this.secondService.getData() }\n    }\n}\n</code></pre> <p>And then in the controller:</p> <pre><code>export class TestDIController extends BaseController {\n    constructor(@Inject(FirstService) protected firstService: FirstService) {\n        super()\n    }\n\n    myView({ response }: HttpContext) {\n        return response.setResponse({\n            body: JSON.stringify(this.firstService.getData()),\n            contentType: \"application/json\"\n        })\n    }\n}\n</code></pre> <p>Tip</p> <p>You can inject as many services as you want.</p> <pre><code>export class TestDIController extends BaseController {\n    constructor(\n        @Inject(FirstService) protected firstService: FirstService,\n        @Inject(SecondService) protected secondService: SecondService,\n    ) {\n        super()\n    }\n\n    myView({ response }: HttpContext) {\n        console.log(this.secondService.getData())\n\n        return response.setResponse({\n            body: JSON.stringify(this.firstService.getData()),\n            contentType: \"application/json\"\n        })\n    }\n}\n</code></pre>"},{"location":"modules/jeran/","title":"@fehujs/ioc","text":"<p>Fehujs apps command launcher.</p>"},{"location":"modules/jeran/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/jeran</p> <p>NPM: @fehujs/jeran</p> <p>Licence: MIT</p>"},{"location":"modules/jeran/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/jeran/reference/","title":"Reference","text":"<p>Tip</p> <p>You can see a demonstration about this by watching at the jeran <code>run</code> function implementation.</p>"},{"location":"modules/jeran/reference/#buildadditionalfiles","title":"<code>buildAdditionalFiles</code>","text":"<p>Arguments: </p> <ul> <li><code>dirPath</code>: string</li> <li><code>outDirPath</code>: string</li> <li><code>tsConfigPath</code>: string (default: \"./tsconfig.json\")</li> </ul> <p>It permits to build files that could be imported dynamically by the main bundle.</p>"},{"location":"modules/jeran/reference/#buildfiles","title":"<code>buildFiles</code>","text":"<p>Arguments:</p> <ul> <li><code>fileName</code>: string</li> <li><code>buildAdditional</code>: (file: string) =&gt; Promise (not required) <p>It permits to bundle and build an endpoint (for example, a file in <code>./bin/</code> in a Fehujs app), the <code>buildAdditional</code> callback permits to execute others build depending on the file identifed.</p>"},{"location":"modules/jeran/reference/#launchcommandexec-string-args-string","title":"<code>launchCommand(exec: string, args: string[])</code>","text":"<p>Runs a command using <code>child_process.spawn()</code>. The <code>exec</code> argument is the name of the executable and the second argument represents the list of the others args.</p>"},{"location":"modules/jeran/reference/#run","title":"<code>run</code>","text":"<p>This function is the endpoint of each Fehujs process. It's this function that identifies the <code>./bin/</code> file to bundle and then to run.</p>"},{"location":"modules/sessions/","title":"@fehujs/sessions","text":"<p>Fehujs sessions handling package.</p> <p>Warning</p> <p>At this time, only the session id handling is implemented.</p>"},{"location":"modules/sessions/#module-configuration","title":"Module configuration","text":"<ul> <li><code>ID_COOKIE_NAME: \"session_id\"</code></li> <li><code>ID_COOKIE_EXPIRES: 1800000</code></li> <li><code>ID_LENGTH: 16</code></li> </ul>"},{"location":"modules/sessions/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/sessions</p> <p>NPM: @fehujs/sessions</p> <p>Licence: MIT</p>"},{"location":"modules/sessions/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/sessions/session-id/","title":"Session id","text":"<p>The session id is is a token that permits to identify requests.</p> <p>It is stored in a cookie.</p> <p>You can customize the token size, and the session id cookie name and expiration date.</p>"},{"location":"modules/sessions/session-id/#getsessionidrequest-request","title":"<code>getSessionId(request: Request)</code>","text":"<p>Get the request's session id. If it doesn't exists, create one.</p>"},{"location":"modules/sessions/session-id/#setsessionidcookie-request-response-httpcontext","title":"<code>setSessionIdCookie({ request, response }: HttpContext)</code>","text":"<p>Set the session id cookie.</p>"},{"location":"modules/template-parser/","title":"@fehujs/template-parser","text":"<p>This is a little guide to help you to use the template system.</p> <p>The syntax is pretty similar to Svelte one's.</p>"},{"location":"modules/template-parser/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/template-parser</p> <p>NPM: @fehujs/template-parser</p> <p>Licence: MIT</p>"},{"location":"modules/template-parser/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/template-parser/block-reference/","title":"Block Reference","text":""},{"location":"modules/template-parser/block-reference/#variables","title":"Variables","text":"<p>Syntax: <pre><code>{{myVar}}\n</code></pre></p>"},{"location":"modules/template-parser/block-reference/#conditions","title":"Conditions","text":"<p>Syntax: <pre><code>{{#if myVar}}\n\n    &lt;!-- some code --&gt;\n\n{{/if}}\n</code></pre></p> <p>Bug</p> <p>Tags else if and else aren't planned to be implemented yet.</p>"},{"location":"modules/template-parser/block-reference/#loops","title":"Loops","text":"<p>Syntax: <pre><code>{{#for i in myArray}}\n\n    &lt;!-- some code--&gt;\n\n{{/for}}\n</code></pre></p>"},{"location":"modules/template-parser/block-reference/#include","title":"Include","text":"<p>Syntax: <pre><code>{{#include ./path/to/included/file.html}}\n    &lt;p&gt;Couldn't load file.html&lt;/p&gt;\n{{/include}}\n</code></pre></p> <p>Tip</p> <p>If the engine can't load the file it will display the block content.</p> <p>Tip</p> <p>The container file's context will apply to all included files.</p>"},{"location":"modules/template-parser/contribute/","title":"Contribute","text":"<p>This page describes more precisely how the parser works, and how you can contribute.</p>"},{"location":"modules/template-parser/contribute/#implement-a-new-block","title":"Implement a new block","text":"<p>This parser parses templates with the help of regex.</p> <p>All you have to do is adding your regex in a constant at the top of the <code>@fehujs/template-parser/handlers.ts</code>, write your handler function that calls the \"replacing function\" and return the template parsed.</p> <p>Then you \"register\" your handler function into the <code>parse(template: string, context: string)</code>.</p> <p>Let's see a little demonstration : how the for loops are implemented.</p> <pre><code>//...\n\nconst REGEX_FORLOOP = /{{#for\\s+(\\w+)\\s+in\\s+(\\w+)}}([\\s\\S]*?){{\\/for}}/g  // (1)!\n\n// ...\n\nfunction forLoopHandler (template: string, context: Context) {  // (2)!\n    return template.replace(\n        REGEX_FORLOOP,\n        (match, itemName, arrayName, content) =&gt; {  // (3)!\n            const items = context[arrayName]\n\n            if (!items) new VariableMissingInContext(arrayName)\n\n            if (Array.isArray(items)) {\n                return items.map(item =&gt; {\n                    const newContext = { ...context }\n                    newContext[itemName] = item\n                    return parse(content, newContext)\n                }).join('')\n            }\n            new WrongTypeVariable(arrayName, typeof arrayName, \"Array\")\n            return ''\n        }\n    )\n}\n\n// ...\n\n\nexport function parse (template: string, context: Context) {\n    // ...\n    template = forLoopHandler(template, context)  // (4)!\n    // ...\n    return template\n}\n</code></pre> <ol> <li>The regex that parses all for loops (you can test it on https://regex101.com/)</li> <li>The handler function</li> <li>The \"replacing function\"</li> <li>That's what I'm talking about when I say \"register\"</li> </ol>"},{"location":"modules/template-parser/contribute/#implement-a-new-error","title":"Implement a new error","text":"<p>You can implement an error by writing a code like this in the <code>template-parser/errors.ts</code>: <pre><code>export class MyError {\n    constructor (arg1: string, arg2: string) {\n        logError(\"MyError\", `${arg1} and ${arg2} must........`)\n    }\n}\n</code></pre></p>"},{"location":"modules/template-parser/demonstration/","title":"Demonstration","text":"<p>In <code>./src/app/controllers/template-demo.ts</code>: <pre><code>export class TemplateDemoController {\n    public async view({ request, response}: HttpContext): Promise&lt;Response&gt; {\n        const messagesSent = 3\n        return response.setResponse({\n            contentType: \"text/html\",\n            body: render(\"./src/templates/demo.html\", {\n                name: \"john doe\",\n                text: \"hello, world!\",\n                messagesSent: messagesSent,\n                msgs: [\"hi\", \"hi1\", \"hi2\"],\n                isSentALotOfMsg: messagesSent &gt; 3  // (1)!\n            })\n        })\n    }\n}\n</code></pre></p> <ol> <li>Nota: conditions aren't supported inside of the template, so put the condition into a variable and do a condition as '{{#if condition}} ...'</li> </ol> <p>In <code>./src/templates/demo.html</code>: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Template Demo&lt;/title&gt;\n\n    &lt;!-- ... --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h3&gt;Hi, {{name}}!&lt;/h3&gt;\n    &lt;p&gt;{{text}}&lt;/p&gt;\n\n    {{#if msgs}}\n        {{#for msg in msgs}}\n            &lt;p&gt;{{msg}}&lt;/p&gt;\n        {{/for}}\n    {{/if}}\n\n    &lt;!-- (1)! --&gt;\n    {{#include src/templates/component.html}}\n        &lt;p&gt;Couldn't load component.html&lt;/p&gt;\n    {{/include}}\n\n    &lt;script src=\"/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <ol> <li>Nota: if the parser couldn't load the component, it will display the block of code between its tags</li> </ol> <p>And <code>./src/templates/conponent.html</code>: <pre><code>&lt;pre&gt;./src/templates/component.html&lt;/pre&gt;\n\n&lt;!-- as you can see, the included templates inherits of the main context --&gt;\n&lt;!-- as I said above, make a condition like this with the condition variable --&gt;\n{{#if isSentALotOfMsg}}\n    &lt;p&gt;You sent us a lot of messages ({{messagesSent}}), thanks&lt;/p&gt;\n{{/if}}\n</code></pre></p> <p>With this example, we get this response: <pre><code>    &lt;!-- ... --&gt;\n\n    &lt;h3&gt;Hi, john doe!&lt;/h3&gt;\n    &lt;p&gt;hello, world!&lt;/p&gt;\n\n\n\n\n\n            &lt;p&gt;hi&lt;/p&gt;\n\n            &lt;p&gt;hi1&lt;/p&gt;\n\n            &lt;p&gt;hi2&lt;/p&gt;\n\n\n\n    &lt;pre&gt;./src/templates/component.html&lt;/pre&gt;\n\n\n&lt;p&gt;You sent us a lot of messages (4), thanks&lt;/p&gt;\n&lt;pre&gt;from component&lt;/pre&gt;\n\n    &lt;!-- ... --&gt;\n</code></pre></p>"},{"location":"modules/template-parser/reference/","title":"Reference","text":""},{"location":"modules/template-parser/reference/#renderpath-string-context-context-string","title":"<code>render(path: string, context: Context): string</code>","text":"<ul> <li><code>path</code>: the path of the template to parse.</li> <li><code>context</code>: the context, in other words the variables that will serve to edit the template.</li> </ul>"},{"location":"modules/template-parser/reference/#context","title":"<code>Context</code>","text":"<p>It is an object of string keys (the variables names) and their values. The values can be string, number, boolean and arrays of string, numbers or booleans.</p>"},{"location":"modules/template-parser/reference/#templatenotfoundpath-string","title":"<code>TemplateNotFound(path: string)</code>","text":"<p>Shows an error message (in console) if a template isn't found. If it's the main template, it returns this HTML in the response: <code>\"&lt;pre&gt;[template-parser] default html template&lt;/pre&gt;\"</code>, if it's an included template it will inject the include tag content (please see Block Reference &gt; Include section).</p>"},{"location":"modules/template-parser/reference/#variablemissingincontextvarname-string","title":"<code>VariableMissingInContext(varName: string)</code>","text":"<p>Shows an error (in console) if a variable called in the template isn't defined in the context.</p>"},{"location":"modules/template-parser/reference/#wrongtypevariablevarname-string-actualtype-string-exceptedtype-string","title":"<code>WrongTypeVariable(varName: string, actualType: string, exceptedType: string)</code>","text":"<p>Shows an error (in console) if a variable isn't of the excepted type.</p>"},{"location":"modules/tsconfig/","title":"@fehujs/tsconfig","text":"<p>TS config base for FehuJS projects.</p>"},{"location":"modules/tsconfig/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/tsconfig</p> <p>NPM: @fehujs/tsconfig</p> <p>Licence: MIT</p>"},{"location":"modules/tsconfig/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/tsconfig/config/","title":"Config","text":""},{"location":"modules/tsconfig/config/#config-from-fehujsbuild","title":"Config from @fehujs/build","text":""},{"location":"modules/tsconfig/config/#compileroptions","title":"<code>compilerOptions</code>","text":""},{"location":"modules/tsconfig/config/#target","title":"<code>target</code>","text":"<p><code>\"ESNext\"</code></p>"},{"location":"modules/tsconfig/config/#module","title":"<code>module</code>","text":"<p><code>\"ESNext\"</code></p>"},{"location":"modules/tsconfig/config/#moduleresolution","title":"<code>moduleResolution</code>","text":"<p><code>\"Bundler\"</code></p>"},{"location":"modules/tsconfig/config/#strict","title":"<code>strict</code>","text":"<p><code>true</code></p>"},{"location":"modules/tsconfig/config/#esmoduleinterop","title":"<code>esModuleInterop</code>","text":"<p><code>true</code></p>"},{"location":"modules/tsconfig/config/#outdir","title":"<code>outDir</code>","text":"<p><code>\"./build\"</code></p>"},{"location":"modules/tsconfig/config/#rootdir","title":"<code>rootDir</code>","text":"<p><code>\".\"</code></p>"},{"location":"modules/tsconfig/config/#skiplibcheck","title":"<code>skipLibCheck</code>","text":"<p><code>true</code></p>"},{"location":"modules/tsconfig/config/#baseurl","title":"<code>baseUrl</code>","text":"<p><code>\".\"</code></p>"},{"location":"modules/tsconfig/config/#experimentaldecorators","title":"<code>experimentalDecorators</code>","text":"<p><code>true</code></p>"},{"location":"modules/tsconfig/config/#emitdecoratormetadata","title":"<code>emitDecoratorMetadata</code>","text":"<p><code>true</code></p>"},{"location":"modules/tsconfig/config/#config-for-projects-extending-this-config","title":"Config for projects extending this config","text":""},{"location":"modules/tsconfig/config/#compileroptions_1","title":"<code>compilerOptions</code>","text":""},{"location":"modules/tsconfig/config/#outdir_1","title":"<code>outDir</code>","text":"<p><code>\"./build\"</code></p>"},{"location":"modules/tsconfig/config/#rootdir_1","title":"<code>rootDir</code>","text":"<p><code>\"./src\"</code></p>"},{"location":"modules/tsconfig/config/#declaration","title":"<code>declaration</code>","text":"<p><code>true</code></p>"},{"location":"modules/tsconfig/config/#removecomments","title":"<code>removeComments</code>","text":"<p><code>false</code></p>"},{"location":"modules/tsconfig/config/#lib","title":"<code>lib</code>","text":"<p><code>[\"@types/node\"]</code></p>"},{"location":"modules/tsconfig/config/#include","title":"<code>include</code>","text":"<p><code>[\"src/**/*\"]</code></p>"},{"location":"modules/tsconfig/config/#exclude","title":"<code>exclude</code>","text":"<p><code>[\"node_modules\"]</code></p>"},{"location":"modules/validator/","title":"@fehujs/validator","text":"<p>This module permits you to parse objects (like request, body) to verify if its processable.</p>"},{"location":"modules/validator/#contribute","title":"Contribute","text":"<p>GitHub repository: fehujs/validator</p> <p>NPM: @fehujs/validator</p> <p>Licence: MIT</p>"},{"location":"modules/validator/#contributors","title":"Contributors","text":"<p>Made with contrib.rocks.</p>"},{"location":"modules/validator/custom-rules/","title":"Validators directory","text":"<p>You can set your schemas in files contained into <code>src/app/validators</code>.</p>"},{"location":"modules/validator/custom-rules/#create-custom-rules","title":"Create custom rules","text":"<p>If you want to create a custom rule, you can create a file named <code>rules.ts</code> into <code>src/app/validators</code>.</p> <p>Then, begin to implement your rules!</p> <pre><code>import type { Rule } from \"@fehujs/validator\"\n\nexport const customRule = (str: string) =&gt; {\n    return {\n        name: \"Custom rule name\",\n        errMsg: \"Custom rule error message\",\n        cb: () =&gt; {\n            if (/** your condition */) return true\n\n            return false\n        }\n    } as Rule\n}\n</code></pre> <p>Now you can easily use this rule in your schemas:</p> <pre><code>    // ...\n    \"customRule\": [],\n    // ...\n</code></pre> <p>Info</p> <p>The first argument of the function is provided by the module, so in the schema declaration you MUST NOT set it as a rule param. But the next arguments MUST be set into the schema declaration.</p> <p>Here's an example:</p> <pre><code>export const myCustomMin = (str: string, min: number, foo: string) =&gt; {\n    return {\n        name: \"Custom minimum string length\",\n        errMsg: \"The string isn't long enough (custom rule)\",\n        cb: () =&gt; {\n            console.log(foo)\n\n            if (str.length &gt;= min) return true\n\n            return false\n        }\n    } as Rule\n}\n</code></pre> <p>As you can see, we added a parameter named <code>min</code> and another named <code>foo</code>. In the schema, the declaration would look like this: <pre><code>    // ...\n    \"myCustomMin\": [\n        8, // min param\n        \"bar\" // foo param\n    ],\n    // ...\n</code></pre></p> <p>Note</p> <p>Please note that the params are handled in the order of declaration, do not put the foo param before the min param.</p>"},{"location":"modules/validator/usage/","title":"Usage","text":"<p>Here's a sign up view process using the validator module:</p> <pre><code>    const schema = await Schema.create({\n        name: {\n            \"optional\": [\"John Doe\"]  // (1)!\n        },\n        email: {\n            \"email\": []\n        },\n        password: {\n            \"min\": [8]\n        }\n    })\n    const body = await schema.parse&lt;SignupPayload&gt;(await getPostBody(req))\n    let user: ModelObject | null\n\n    if (!body.success) {\n        // error: the body doesn't math with the schema \n    }\n\n    try {\n        user = await User.create({\n            name: body.data.name,\n            email: body.data.email,\n            password: body.data.password\n        })\n    } catch (err: any) {\n        // error: error while creating user (email already taken, ...)\n    }\n</code></pre> <ol> <li>You can set a default value if you want (if the field is empty, the default value will be set).</li> </ol> <p>The first part consists to defining our schema. The schema is an object which keys will be the fields of the parsed object (here, the request body). In each key, you can put an object containing the rules that the field must comply with.</p> <p>A simple draft of what it means: <pre><code>{\n    field1: {\n        rule1: [\"rule1 param1\", \"rule1 param2\"]\n        rule2: [\"rule2 param1\"]\n    },\n    field2: {\n        rule3: []\n    }\n}\n</code></pre></p> <p>Then comes the request parsing: <code>await schema.parse&lt;SignupPayload&gt;(request.body)</code></p> <p>You specify in parameters of the async method <code>schema.parse()</code> the object to parse, and you must provide the output type.</p> <p>Let's say that  <pre><code>type SignupPayload = {\n    name: string\n    email: string\n    password: string\n}\n</code></pre></p> <p>To the <code>schema.parse()</code> output will be typed as</p> <pre><code>{\n    success: boolean\n    data: SignupPayload\n}\n</code></pre> <p>So you can verify if the parsing is a success or not with <code>success</code>.</p> <p>If the parsing is a success, you can get the parsed data by accessing to (in this example) <code>body.data</code>.</p> <p>Note</p> <p>If the parsing isn't valid, the <code>data</code> object will contain the errors of each field.</p> <p>E.g: if the request body was something like  <pre><code>{\n    email: \"e\",\n    password: \"123\"\n}\n</code></pre></p> <p>the <code>schema.parse()</code> return would be</p> <pre><code>{\n    success: false,\n    data: {\n        name: \"\",\n        email: \"Invalid email\",\n        password: \"Text isn't long enough, excepted a 8 characters minimum text\"\n    }\n}\n</code></pre>"}]}